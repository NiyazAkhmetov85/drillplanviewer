<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drill Plan Viewer (ЛСК)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://unpkg.com/react-leaflet@3.2.1/dist/react-leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <style>
        /* Стиль для родительского контейнера карты */
        #map-container {
            height: 60vh;
            min-height: 400px;
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        /* Стили для маркера конца скважины */
        .end-marker div {
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .file-upload-label {
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            background-color: #3b82f6; /* blue-500 */
            color: white;
            transition: background-color 0.2s;
            text-align: center;
        }
        .file-upload-label:hover {
            background-color: #2563eb; /* blue-600 */
        }
        /* Скрываем стандартный инпут */
        #file-upload {
            display: none;
        }
        .table-wrapper {
            max-height: 300px;
            overflow-y: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            text-align: left;
        }
        th {
            background-color: #f3f4f6;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Исправление проблемы с иконками Leaflet */
        .leaflet-default-icon-path {
            background-image: url("https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png");
        }
    </style>
</head>
<body class="bg-gray-100 p-4 sm:p-8">

    <div id="root" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-2xl">
        </div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { MapContainer, TileLayer, Marker, Popup, Polyline, useMap } = ReactLeaflet;

        // --- ГЕОМЕТРИЧЕСКИЕ КОНСТАНТЫ И ЛОГИКА ТРАНСФОРМАЦИИ ---
        
        // --- КОНСТАНТЫ ТРАНСФОРМАЦИИ (Извлечены из AltynTau_coord_sys_report.pdf) ---
        const TX = 4458.9140; // Сдвиг по X 
        const TY = 7317.3475; // Сдвиг по Y 
        const ROT_GON = 398.9098; // Параметр поворота в гонах (grads)
        const SCALE = 1.000097549103;

        // Преобразование угла поворота из гон в радианы
        // Угол R = (398.9098 - 400.0) гон.
        const R_RAD = (ROT_GON - 400.0) * (Math.PI / 200.0);

        const COS_R = Math.cos(R_RAD);
        const SIN_R = Math.sin(R_RAD);

        const FACTOR_A = SCALE * COS_R;
        const FACTOR_B = SCALE * SIN_R;
        
        /**
         * Применяет 2D трансформацию Гельмерта (Сдвиг, Поворот, Масштаб)
         */
        const transformRawToLocal = (x_raw, y_raw) => {
            const X_local = TX + (FACTOR_A * x_raw) - (FACTOR_B * y_raw);
            const Y_local = TY + (FACTOR_B * x_raw) + (FACTOR_A * y_raw);
            
            return { x: X_local, y: Y_local };
        };

        // Функция для очистки и преобразования числового значения (замена ',' на '.')
        const cleanAndParse = (value) => {
            if (value === null || value === undefined || String(value).trim() === '') {
                return 0;
            }
            return parseFloat(String(value).replace(',', '.'));
        };
        
        // --- ОБРАБОТКА ДАННЫХ ---
        const processData = (rawData, setError, setDrillHoles, setLoading) => {
            try {
                // Создаем стандартизированную карту имен полей, чтобы избежать проблем с регистром/пробелами
                const standardizedKeys = [
                    'HoleName', 'RawStartPointX', 'RawStartPointY', 'RawStartPointZ', 
                    'RawEndPointX', 'RawEndPointY', 'RawEndPointZ'
                ];
                
                // Находим реальные ключи в данных, соответствующие нашим стандартным
                const actualKeys = {};
                if (rawData.length > 0) {
                    const firstRowKeys = Object.keys(rawData[0]);
                    standardizedKeys.forEach(stdKey => {
                        const foundKey = firstRowKeys.find(
                            // Ищем ключ, игнорируя регистр и пробелы
                            k => String(k).trim().toLowerCase() === stdKey.toLowerCase()
                        );
                        if (foundKey) {
                            actualKeys[stdKey] = foundKey;
                        } else {
                            // Если не найдено, используем стандартное имя, надеясь, что оно совпадает
                            actualKeys[stdKey] = stdKey;
                        }
                    });
                }


                const processedData = rawData
                    .map((item, index) => {
                        // Извлекаем и парсим данные, используя найденные реальные ключи
                        const rawStartX = cleanAndParse(item[actualKeys['RawStartPointX']]);
                        const rawStartY = cleanAndParse(item[actualKeys['RawStartPointY']]);
                        const rawStartZ = cleanAndParse(item[actualKeys['RawStartPointZ']]);

                        const rawEndX = cleanAndParse(item[actualKeys['RawEndPointX']]);
                        const rawEndY = cleanAndParse(item[actualKeys['RawEndPointY']]);
                        const rawEndZ = cleanAndParse(item[actualKeys['RawEndPointZ']]);

                        // Применяем трансформацию Гельмерта к начальной и конечной точке (X, Y)
                        const localStartCoords = transformRawToLocal(rawStartX, rawStartY);
                        const localEndCoords = transformRawToLocal(rawEndX, rawEndY);

                        return {
                            id: index,
                            HoleName: item[actualKeys['HoleName']] || `Скважина ${index + 1}`,
                            
                            // Локальные координаты
                            LocalStartPointX: localStartCoords.x,
                            LocalStartPointY: localStartCoords.y,
                            LocalStartPointZ: rawStartZ,

                            LocalEndPointX: localEndCoords.x,
                            LocalEndPointY: localEndCoords.y,
                            LocalEndPointZ: rawEndZ,
                            
                            // Исходные координаты (для отображения в таблице)
                            RawStartPointX: rawStartX,
                            RawStartPointY: rawStartY,
                        };
                    })
                    .filter(item =>
                        // Фильтруем строки, где не удалось найти валидные X/Y координаты
                        item.RawStartPointX !== 0 || item.RawStartPointY !== 0
                    );

                if (processedData.length === 0) {
                    setError('Не найдено валидных данных с координатами для отображения.');
                    setDrillHoles([]);
                } else {
                    setDrillHoles(processedData);
                }

            } catch (e) {
                setError(`Ошибка обработки данных или трансформации координат: ${e.message}`);
                console.error("Processing Error:", e);
            } finally {
                setLoading(false);
            }
        };

        // --- КОМПОНЕНТ КАРТЫ И ЛОГИКА ЦЕНТРИРОВАНИЯ ---
        
        // Исправление проблемы с иконками Leaflet
        delete L.Icon.Default.prototype._getIconUrl;
        L.Icon.Default.mergeOptions({
            iconRetinaUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon-2x.png',
            iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
            shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
        });

        const endMarkerIcon = L.divIcon({ 
            className: 'end-marker', 
            html: '<div style="background-color: blue; width: 8px; height: 8px; border-radius: 50%;"></div>',
            iconSize: [8, 8],
            iconAnchor: [4, 4]
        });

        // Компонент для автоматического изменения границ карты при обновлении данных
        const ChangeView = ({ bounds }) => {
            const map = useMap();
            useEffect(() => {
                if (bounds && bounds.length > 0) {
                    const leafletBounds = L.latLngBounds(bounds);
                    if (leafletBounds.isValid()) {
                         // Leaflet fitBounds работает с массивом [lat, lng]
                        map.fitBounds(leafletBounds, { padding: [50, 50], maxZoom: 18 }); 
                        console.log('MapComponent: Fitting bounds:', leafletBounds.toBBoxString());
                    } else {
                        // Если bounds невалидны (например, одна точка), просто центрируем ее
                        map.setView(bounds[0], 18);
                        console.log('MapComponent: Setting view to single point:', bounds[0]);
                    }
                }
            }, [bounds, map]);
            return null;
        };
        
        const MapComponent = ({ data }) => {
            // В Leaflet [Lat, Lng] соответствует [Y, X] при использовании L.CRS.Simple
            
            // 1. Получаем все точки для определения границ карты
            const allCoords = data.flatMap(item => [
                // [Y_Local, X_Local]
                [item.LocalStartPointY, item.LocalStartPointX],
                [item.LocalEndPointY, item.LocalEndPointX]
            ]).filter(coord => !isNaN(coord[0]) && !isNaN(coord[1])); 

            // Если данных нет, используем дефолтный центр
            const center = allCoords.length > 0 ? allCoords[0] : [7250, 4250]; 

            // Принудительное центрирование при первом рендере
            const initialBounds = allCoords.length > 0 ? allCoords : [[7250, 4250], [7251, 4251]];


            return (
                <MapContainer 
                    center={center}
                    zoom={13} 
                    scrollWheelZoom={true} 
                    style={{ height: '100%', width: '100%', backgroundColor: '#f0f0f0' }}
                    // !!! КАРТЕЗИАНСКАЯ СИСТЕМА КООРДИНАТ !!!
                    crs={L.CRS.Simple} 
                    maxZoom={20}
                    minZoom={2} 
                >
                    {/* Этот компонент автоматически центрирует карту при загрузке новых данных */}
                    <ChangeView bounds={allCoords} />

                    <TileLayer
                        attribution='Drill Plan Viewer (ЛСК)'
                        url="" 
                        opacity={0.0}
                    />

                    {data.map((item, index) => {
                        // Leaflet ожидает [Y, X]
                        const startPoint = [item.LocalStartPointY, item.LocalStartPointX];
                        const endPoint = [item.LocalEndPointY, item.LocalEndPointX];
                        
                        if (isNaN(startPoint[0]) || isNaN(startPoint[1])) return null;

                        const path = [startPoint, endPoint];
                        
                        return (
                            <React.Fragment key={index}>
                                {/* 1. Линия скважины (Красный цвет) */}
                                <Polyline positions={path} color="#dc3545" weight={3} opacity={0.8} />

                                {/* 2. Маркер начала скважины (Стандартный Leaflet маркер) */}
                                <Marker position={startPoint}>
                                    <Popup>
                                        <strong>{item.HoleName || 'N/A'}</strong> (Начало)<br/>
                                        X: {item.LocalStartPointX.toFixed(3)} м<br/>
                                        Y: {item.LocalStartPointY.toFixed(3)} м<br/>
                                        Z: {item.LocalStartPointZ.toFixed(3)} м
                                    </Popup>
                                </Marker>
                                
                                {/* 3. Маркер конца скважины (Синяя точка) */}
                                <Marker position={endPoint} icon={endMarkerIcon}>
                                    <Popup>
                                        <strong>{item.HoleName || 'N/A'}</strong> (Конец)<br/>
                                        X: {item.LocalEndPointX.toFixed(3)} м<br/>
                                        Y: {item.LocalEndPointY.toFixed(3)} м<br/>
                                        Z: {item.LocalEndPointZ.toFixed(3)} м
                                    </Popup>
                                </Marker>
                            </React.Fragment>
                        );
                    })}
                </MapContainer>
            );
        };


        // --- ОСНОВНОЙ КОМПОНЕНТ APP ---
        function App() {
            const [drillHoles, setDrillHoles] = useState([]);
            const [error, setError] = useState(null);
            const [loading, setLoading] = useState(false);
            const [fileName, setFileName] = useState('');

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setLoading(true);
                setError(null);
                setFileName(file.name);
                setDrillHoles([]);

                const fileExtension = file.name.split('.').pop().toLowerCase();

                const commonReader = (fileData) => {
                    // Используем Papa.parse для CSV
                    if (fileExtension === 'csv') {
                         Papa.parse(file, {
                            header: true,
                            skipEmptyLines: true,
                            dynamicTyping: false,
                            complete: (results) => {
                                if (results.errors.length) {
                                    setError(`Ошибка парсинга CSV: ${results.errors[0].message}`);
                                    setLoading(false);
                                    return;
                                }
                                processData(results.data, setError, setDrillHoles, setLoading);
                            },
                            error: (err) => {
                                setError(`Ошибка чтения файла: ${err.message}`);
                                setLoading(false);
                            }
                        });
                        return;
                    }
                    
                    // Логика для XLSX/XLS (файл уже прочитан как ArrayBuffer)
                    if (fileExtension === 'xlsx' || fileExtension === 'xls') {
                        try {
                            const workbook = XLSX.read(fileData, { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[sheetName];
                            
                            // Получаем данные как массив объектов с заголовками
                            const dataObjects = XLSX.utils.sheet_to_json(worksheet);

                            if (dataObjects.length === 0) {
                                setError('Файл Excel пуст или не содержит корректных данных.');
                                setLoading(false);
                                return;
                            }

                            processData(dataObjects, setError, setDrillHoles, setLoading);

                        } catch (e) {
                            setError(`Ошибка парсинга Excel: ${e.message}. Убедитесь, что заголовки находятся в первой строке.`);
                            setLoading(false);
                            console.error("XLSX Parsing Error:", e);
                        }
                        return;
                    }
                    
                     setError(`Неподдерживаемый формат файла: ${fileExtension}. Поддерживаются только CSV, XLSX и XLS.`);
                     setLoading(false);
                };


                if (fileExtension === 'csv') {
                    // Для CSV-файлов передаем сам объект File в PapaParse
                    commonReader(file);
                } else if (fileExtension === 'xlsx' || fileExtension === 'xls') {
                    // Для Excel-файлов нужен ArrayBuffer
                    const reader = new FileReader();
                    reader.onload = (e) => commonReader(new Uint8Array(e.target.result));
                    reader.onerror = (e) => {
                        setError(`Ошибка чтения файла (FileReader): ${e.target.error.message}`);
                        setLoading(false);
                    };
                    reader.readAsArrayBuffer(file);
                } else {
                    setError(`Неподдерживаемый формат файла: ${fileExtension}. Поддерживаются только CSV, XLSX и XLS.`);
                    setLoading(false);
                }
            };

            // --- ИНТЕРФЕЙС И ОТОБРАЖЕНИЕ ---
            return (
                <div className="flex flex-col gap-6">
                    <header>
                        <h1 class="text-3xl font-bold text-gray-800">Drilling Plan Viewer (ЛСК)</h1>
                        <p class="text-gray-500">Визуализация скважин на карте в локальной системе координат.</p>
                    </header>
                    
                    <div className="flex flex-col sm:flex-row gap-4 items-center">
                        <input 
                            type="file" 
                            accept=".csv,.xlsx,.xls"
                            onChange={handleFileUpload} 
                            disabled={loading}
                            id="file-upload"
                        />
                        <label htmlFor="file-upload" className={`file-upload-label flex-grow ${loading ? 'opacity-75 cursor-not-allowed' : ''}`}>
                            {loading 
                                ? 'Обработка данных...' 
                                : drillHoles.length > 0 
                                    ? `Загружено ${drillHoles.length} скважин. Выбрать другой файл.`
                                    : fileName ? `Файл ${fileName} загружен. Загрузить новый.` : 'Нажмите, чтобы загрузить CSV, XLSX или XLS файл'}
                        </label>
                    </div>
                    
                    {error && <p className="error-message text-red-600 font-medium bg-red-100 p-3 rounded-lg">⚠️ Ошибка: {error}</p>}
                    
                    {/* Контейнер карты */}
                    {drillHoles.length > 0 ? (
                        <div id="map-container">
                            <MapComponent data={drillHoles} />
                        </div>
                    ) : (
                        !loading && !error && (
                            <div className="bg-gray-50 p-6 rounded-lg text-center text-gray-600 h-64 flex items-center justify-center">
                                <p>Загрузите CSV/XLSX/XLS-файл с паспортами бурения для отображения плана на карте (Локальная СК).</p>
                            </div>
                        )
                    )}

                    {/* Секция для просмотра данных */}
                    {drillHoles.length > 0 && (
                        <React.Fragment>
                            <h2 className="text-2xl font-semibold mt-4 text-gray-700">Обработанные данные (Начальные точки, {drillHoles.length} записей)</h2>
                            <div className="table-wrapper border rounded-lg shadow-sm">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Имя скважины</th>
                                            <th>X (Лок.)</th>
                                            <th>Y (Лок.)</th>
                                            <th>Z (Лок.)</th>
                                            <th class="text-gray-500">X (Исходн.)</th>
                                            <th class="text-gray-500">Y (Исходн.)</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {drillHoles.slice(0, 50).map((item) => ( 
                                            <tr key={item.id}>
                                                <td class="font-mono text-sm">{item.HoleName || 'N/A'}</td>
                                                <td class="font-mono text-sm text-green-700">{item.LocalStartPointX.toFixed(3)}</td>
                                                <td class="font-mono text-sm text-green-700">{item.LocalStartPointY.toFixed(3)}</td>
                                                <td class="font-mono text-sm">{item.LocalStartPointZ.toFixed(3)}</td>
                                                <td class="font-mono text-sm text-gray-500">{item.RawStartPointX.toFixed(3)}</td>
                                                <td class="font-mono text-sm text-gray-500">{item.RawStartPointY.toFixed(3)}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                                {drillHoles.length > 50 && <p className="p-2 text-sm text-gray-500">Показаны первые 50 записей.</p>}
                            </div>
                        </React.Fragment>
                    )}
                </div>
            );
        }

        // Рендеринг приложения
        ReactDOM.render(<App />, document.getElementById('root'));

    </script>
</body>
</html>
